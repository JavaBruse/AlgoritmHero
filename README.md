## GeneratePresetImpl

### Этапы алгоритма:

1. **Сортировка списка юнитов**
    - Сложность этого этапа: `O(n log n)`.

2. **Итерация по отсортированному списку**
    - В результате, каждый итерационный шаг имеет сложность `O(m * n)`.

3. **Обновление данных в каждом шаге**

    - Каждое обновление имеет сложность `O(1)`.

### Итоговая сложность:

- Сложность сортировки: `O(n log n)`.
- Внутренний цикл с добавлением юнитов: сложность линейная на каждый итерационный шаг — `O(m * n)`.

Таким образом, итоговая сложность алгоритма составит:
- `O(n logn n)`

## SimulateBattleImpl

### Этапы алгоритма:

1. **Сортировка атакующих юнитов (`attackers.sort(Comparator.comparingInt(Unit::getBaseAttack).reversed())`)**:
    - Сортировка используется для каждого раунда. Это операция `O(n log n)`, где `n` — количество юнитов в списке
      атакующих.

2. **Обработка каждого юнита в отсортированном списке**:
    - Для каждого юнита выполняется:
        - Проверка живой ли юнит (`!attacker.isAlive()`) — `O(1)`.
        - Если жив, выбор цели (`Unit target = attacker.getProgram().attack()`) — `O(1)`.
        - Печать лога боя (`printBattleLog.printBattleLog(attacker, target)`) — `O(1)`.

   Таким образом, в худшем случае для каждого раунда будет выполняться `O(n)` действий, где `n` — количество атакующих
   юнитов в текущем раунде.

### Итоговая сложность:
- В каждом раунде выполняется `O(n log n)`
- (сортировка) + `O(n)`
- (обработка юнитов), что дает сложность `O(n log n + n)`, которую можно упростить до `O(n log n)`.

## SuitableForAttackUnitsFinderImpl
### Этапы алгоритма:
1. **Создание списка юнитов** `O(1)`
2. **Создание HashSet для отслеживания занятых координат Y** `O(1)`
3. **Определение числа строк (рядов) и направления** `O(1)`
4. **Вложенный цикл для каждого ряда** `O(n)`
### Итоговая сложность: `O(n)`

## UnitTargetPathFinderImpl

1. **Инициализация начального состояния грида**
   - Заполняются двумерные массивы `WIDTH * HEIGHT`, где `WIDTH = 27` и `HEIGHT = 21`.
   - Таким образом, сложность этого этапа:  
     O(WIDTH \times HEIGHT) = O(27 \times 21) = O(567).


2. **Добавление занятых клеток от других юнитов**
   - В худшем случае все клетки будут добавлены в множество, т.е. сложность этого этапа:  
     O(|otherUnits|), где `|otherUnits|` — количество юнитов.


3. **Основной цикл поиска пути**
   - Для каждой клетки выполняется до 8 операций (по всем направлениям), а количество посещаемых клеток в худшем случае равно `WIDTH * HEIGHT`.
   - Таким образом, сложность основной части алгоритма:  
     O(WIDTH \times HEIGHT \times 8) = O(27 \times 21 \times 8) = O(4536).

4. **Построение пути**
   - В худшем случае все клетки посещаются для построения пути, т.е. сложность:  
     O(WIDTH \times HEIGHT) = O(27 \times 21) = O(567).

### Итоговая сложность:
- `O(max(567, |otherUnits|, 4536))`

где:
567 — сложность инициализации.

|otherUnits| — зависит от количества других юнитов.

4536 — сложность основного цикла.

